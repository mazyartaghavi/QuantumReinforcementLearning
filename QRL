{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Quantum Approximate Q-learning with Parametrized Quantum Circuits\n",
    "\n",
    "In this Notebook we are going to implement a Quantum version of the Reinforcement Learning technique called Deep Q-learning, which uses a Deep Neural Network, named *Deep Q-Network* (hence DQN), to approximate the optimal state-action pair Q-values $Q^\\ast(s,a)$ characterizing the reinforcement learning task to be solved.  \n",
    "\n",
    "But since this is a Qiskit's Hackathon, let's throw some quantumness in there! \n",
    "In fact, a natural question arise in the mind of a quantum enthusiast: what if we substitute the Deep Neural Network with a quantum parametric circuit, playing the role of a Quantum Neural Network? That's exactly the approach we are going to follow in this notebook, and in particular we are recreating a simplified, yet efficient, version of the algorithm proposed by Skolik et al [[1]](#1), but written entirely in Qiskit! \n",
    "\n",
    "For this project, we will be using the brand new Qiskit Machine Learning [[2]](#2) module to create the quantum neural network and iterface it with PyTorch [[3]](#3) using Qiskit's `TorchConnector` to use fast and seamless evaluation of gradients! At last, we connect this setup with the `CartPole` environment created using OpenAI `gym` [[4]](#4), an open-source library for Reinforcement Learning.  \n",
    "\n",
    "Without further ado, let's code! \n",
    "\n",
    "---\n",
    "### References\n",
    "\n",
    "<a id=\"1\">[1]</a> \n",
    "Andrea Skolik, Sofiene Jerbi and Vedran Dunjko (2019), *Quantum agents in the Gym: a variational quantum algorithm for deep Q-learning*, [arXiv:2103.15084](https://arxiv.org/abs/2103.15084).\n",
    "\n",
    "<a id=\"2\">[2]</a> \n",
    "IBM, Qiskit Quantum Machine Learning repository, [GitHub](https://github.com/Qiskit/qiskit-machine-learning).\n",
    "\n",
    "<a id=\"3\">[3]</a> \n",
    "Adam Paszke, Sam Gross, Soumith Chintala, Gregory Chanan, Edward Yang, Zachary DeVito, Zeming Lin, Alban Desmaison, Luca Antiga,  and Adam Lerer (2017), *Automatic differentiation in PyTorch*, NIPS-W. PyTorch [Website](https://pytorch.org/), [GitHub](https://github.com/pytorch/pytorch).\n",
    "\n",
    "<a id=\"4\">[4]</a> \n",
    "OpenAI [Website](https://openai.com/), [Github](https://github.com/openai/gym)."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Import of relevant packages"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "# General imports\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# Qiskit Circuit imports\n",
    "from qiskit.circuit import QuantumCircuit, QuantumRegister, Parameter, ParameterVector, ParameterExpression\n",
    "from qiskit.circuit.library import TwoLocal\n",
    "\n",
    "# Qiskit imports\n",
    "import qiskit as qk\n",
    "from qiskit.utils import QuantumInstance\n",
    "\n",
    "# Qiskit Machine Learning imports\n",
    "import qiskit_machine_learning as qkml\n",
    "from qiskit_machine_learning.neural_networks import CircuitQNN\n",
    "from qiskit_machine_learning.connectors import TorchConnector\n",
    "\n",
    "# PyTorch imports\n",
    "import torch\n",
    "from torch import Tensor\n",
    "from torch.nn import MSELoss\n",
    "from torch.optim import LBFGS, SGD, Adam, RMSprop\n",
    "\n",
    "# OpenAI Gym import\n",
    "import gym\n",
    "\n",
    "# Fix seed for reproducibility\n",
    "seed = 42\n",
    "np.random.seed(seed)\n",
    "torch.manual_seed(seed);\n",
    "\n",
    "# To get smooth animations on Jupyter Notebooks. \n",
    "# Note: these plotting function are taken from https://github.com/ageron/handson-ml2\n",
    "import matplotlib as mpl\n",
    "import matplotlib.animation as animation\n",
    "mpl.rc('animation', html='jshtml')\n",
    "\n",
    "def update_scene(num, frames, patch):\n",
    "    patch.set_data(frames[num])\n",
    "    return patch,\n",
    "\n",
    "def plot_animation(frames, repeat=False, interval=40):\n",
    "    fig = plt.figure()\n",
    "    patch = plt.imshow(frames[0])\n",
    "    plt.axis('off')\n",
    "    anim = animation.FuncAnimation(\n",
    "        fig, update_scene, fargs=(frames, patch),\n",
    "        frames=len(frames), repeat=repeat, interval=interval)\n",
    "    plt.close()\n",
    "    return anim"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Definition of the *Parametrized Quantum Circuit* (PQC)  \n",
    "\n",
    "The first step in our Quantum Reinforcement Learning journey with quantum neural networks, is to choose the specific structure of the quantum circuit.  \n",
    "\n",
    "In particular, we need two things: first, a way to encode classical data into a quantum circuit, second a parametrized variational circuit, which is the trainable part of the quantum neural network that we optimize to solve the reinforcement learning task. As said previously, we implement the same structure proposed in [[1]](#1).  \n",
    "\n",
    "So, we define the following two functions, `encoding_circuit` and  `parametrized_circuit`, each implementing one of the two steps above.\n",
    "\n",
    "##### `encoding_circuit`\n",
    "\n",
    "This function is used to load on the circuit the classical inputs. In our case, the inputs are the state variables of the `CartPole` environment, which consists of an array of 4 numbers, i.e. the state of the system is given by $\\vec{s} \\in \\mathbb{R}^4$. These features are encoded on a quantum register of 4 qubits initized in zero $|0000\\rangle$ by means of $R_x$ rotations.\n",
    "\n",
    "####  `parametrized_circuit`  \n",
    "\n",
    "This function creates the full parametrized quantum circuit, given by econding plus variational ansatz. The variational ansatz consists of a repeated structure of $R_y$ and $R_z$ rotations, followed by a circular entagling scheme made of $CZ$ gates. It is possible to choose the number of repetitions (*layers*) in the variational quantum circuit, as well as wether to use *data reuploading*, i.e. loading again the classical data at the start of each new layer, in order to increase the circuit's expressivity (see [[1]](#1) for further details).  \n",
    "Both inputs and weights (trainable parameters) are created as Qiskit's `Parameters`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "def encoding_circuit(inputs, num_qubits = 4, *args):\n",
    "    \"\"\"\n",
    "    Encode classical input data (i.e. the state of the enironment) on a quantum circuit. \n",
    "    To be used inside the `parametrized_circuit` function. \n",
    "    \n",
    "    Args\n",
    "    -------\n",
    "    inputs (list): a list containing the classical inputs.\n",
    "    num_qubits (int): number of qubits in the quantum circuit.\n",
    "    \n",
    "    Return\n",
    "    -------\n",
    "    qc (QuantumCircuit): quantum circuit with encoding gates.\n",
    "    \n",
    "    \"\"\"\n",
    "    \n",
    "    qc = qk.QuantumCircuit(num_qubits)\n",
    "    \n",
    "    # Encode data with a RX rotation\n",
    "    for i in range(len(inputs)): \n",
    "        qc.rx(inputs[i], i)\n",
    "        \n",
    "    return qc\n",
    "\n",
    "def parametrized_circuit(num_qubits = 4, reuploading = False, reps = 2, insert_barriers = True, meas = False):\n",
    "    \"\"\"\n",
    "    Create the Parameterized Quantum Circuit (PQC) for estimating Q-values.\n",
    "    It implements the architecure proposed in Skolik et al. arXiv:2104.15084.\n",
    "    \n",
    "    Args\n",
    "    -------\n",
    "    num_qubit (int): number of qubits in the quantum circuit. \n",
    "    reuploading (bool): True if want to use data reuploading technique.\n",
    "    reps (int): number of repetitions (layers) in the variational circuit. \n",
    "    insert_barrirerd (bool): True to add barriers in between gates, for better drawing of the circuit. \n",
    "    meas (bool): True to add final measurements on the qubits. \n",
    "    \n",
    "    Return\n",
    "    -------\n",
    "    qc (QuantumCircuit): the full parametrized quantum circuit. \n",
    "    \"\"\"\n",
    "    \n",
    "    qr = qk.QuantumRegister(num_qubits, 'qr')\n",
    "    qc = qk.QuantumCircuit(qr)\n",
    "    \n",
    "    if meas:\n",
    "        qr = qk.QuantumRegister(num_qubits, 'qr')\n",
    "        cr = qk.ClassicalRegister(num_qubits, 'cr')\n",
    "        qc = qk.QuantumCircuit(qr,cr)\n",
    "    \n",
    "    \n",
    "    if not reuploading:\n",
    "        \n",
    "        # Define a vector containg Inputs as parameters (*not* to be optimized)\n",
    "        inputs = qk.circuit.ParameterVector('x', num_qubits)\n",
    "                \n",
    "        # Encode classical input data\n",
    "        qc.compose(encoding_circuit(inputs, num_qubits = num_qubits), inplace = True)\n",
    "        if insert_barriers: qc.barrier()\n",
    "        \n",
    "        # Variational circuit\n",
    "        qc.compose(TwoLocal(num_qubits, ['ry', 'rz'], 'cz', 'circular', \n",
    "               reps=reps, insert_barriers= insert_barriers, \n",
    "               skip_final_rotation_layer = True), inplace = True)\n",
    "        if insert_barriers: qc.barrier()\n",
    "        \n",
    "        # Add final measurements\n",
    "        if meas: qc.measure(qr,cr)\n",
    "        \n",
    "    elif reuploading:\n",
    "        \n",
    "        # Define a vector containg Inputs as parameters (*not* to be optimized)\n",
    "        inputs = qk.circuit.ParameterVector('x', num_qubits)\n",
    "                \n",
    "        # Define a vector containng variational parameters\n",
    "        θ = qk.circuit.ParameterVector('θ', 2 * num_qubits * reps)\n",
    "        \n",
    "        # Iterate for a number of repetitions\n",
    "        for rep in range(reps):\n",
    "\n",
    "            # Encode classical input data\n",
    "            qc.compose(encoding_circuit(inputs, num_qubits = num_qubits), inplace = True)\n",
    "            if insert_barriers: qc.barrier()\n",
    "                \n",
    "            # Variational circuit (does the same as TwoLocal from Qiskit)\n",
    "            for qubit in range(num_qubits):\n",
    "                qc.ry(θ[qubit + 2*num_qubits*(rep)], qubit)\n",
    "                qc.rz(θ[qubit + 2*num_qubits*(rep) + num_qubits], qubit)\n",
    "            if insert_barriers: qc.barrier()\n",
    "                \n",
    "            # Add entanglers (this code is for a circular entangler)\n",
    "            qc.cz(qr[-1], qr[0])\n",
    "            for qubit in range(num_qubits-1):\n",
    "                qc.cz(qr[qubit], qr[qubit+1])\n",
    "            if insert_barriers: qc.barrier()\n",
    "                        \n",
    "        # Add final measurements\n",
    "        if meas: qc.measure(qr,cr)\n",
    "        \n",
    "    return qc"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Create the PQC  \n",
    "\n",
    "We can use the functions just defined to create the Parametrized Quantum Circuit:"
   ]
  }
